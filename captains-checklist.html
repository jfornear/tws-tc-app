<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="theme-color" content="#FF4B00">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="TWS 2025">
    <meta name="format-detection" content="telephone=no">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-touch-fullscreen" content="yes">
    <link rel="manifest" href="manifest.json">
    <link rel="apple-touch-icon" href="icons/icon-192.png">
    <title>Texas Water Safari 2025 - Captain's Checklist</title>
    <style>
        /* ===== BASE STYLES ===== */
        /* CSS RESET */
        html, body {
            width: 100%;
            height: 100%;
            overscroll-behavior: none;
            -webkit-overflow-scrolling: touch;
            touch-action: manipulation;
        }
        *, *::before, *::after {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            -webkit-tap-highlight-color: transparent;
        }
        html {
            color-scheme: dark;
        }
        :root {
            --suunto-black: #181A1B;
            --suunto-card: #232425;
            --suunto-orange: #FF4B00;
            --strava-orange: #FC4C02;
            --suunto-blue: #0090FF;
            --suunto-white: #F5F5F5;
            --suunto-gray: #B0B0B0;
        }
        body {
            font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif;
            background: var(--suunto-black);
            color: var(--suunto-white);
            min-height: 100vh;
            width: 100%;
            max-width: 100%;
            overflow-x: hidden;
            padding-top: env(safe-area-inset-top);
            padding-bottom: env(safe-area-inset-bottom);
            padding-left: env(safe-area-inset-left);
            padding-right: env(safe-area-inset-right);
            position: relative;
            -webkit-user-select: none;
            user-select: none;
        }
        h1, h2, h3, h4, h5, h6 {
            font-family: inherit;
            font-weight: 700;
            letter-spacing: 0.01em;
            line-height: 1.2;
        }
        h1 {
            font-size: 2em;
            margin-bottom: 10px;
            letter-spacing: 0.02em;
        }

        /* ===== LAYOUT ===== */
        #checkpoints {
            width: 100%;
            max-width: 600px;
            overflow-y: auto;
            overflow-x: hidden;
            -webkit-overflow-scrolling: touch;
            padding: 0 env(safe-area-inset-left) 0 env(safe-area-inset-right);
            margin: 0 auto;
        }
        header {
            text-align: center;
            margin-bottom: 16px;
            padding: 28px 0 16px 0;
            background: var(--suunto-black);
            width: 100%;
            max-width: 600px;
            margin-left: auto;
            margin-right: auto;
        }
        .race-controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            column-gap: 16px;
            justify-content: center;
            margin: 22px 0 0 0;
            background: none;
            box-shadow: none;
            padding: 0 12px;
            width: 100%;
            max-width: 600px;
            margin-left: auto;
            margin-right: auto;
        }
        .race-timer {
            font-family: 'Share Tech Mono', 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, monospace;
            font-size: 2.5em;
            font-weight: 700;
            text-align: center;
            margin: 28px auto 0 auto;
            color: var(--suunto-orange);
            border-radius: 32px;
            padding: 28px 0;
            width: 100%;
            max-width: 600px;
            letter-spacing: 0.09em;
        }
        .race-status {
            text-align: center;
            margin: 16px 0 0 0;
            font-size: 1.18em;
            font-weight: 600;
            color: var(--suunto-orange);
            letter-spacing: 0.03em;
        }

        /* ===== CHECKPOINT CARD ===== */
        .checkpoint {
            background: var(--suunto-card);
            color: var(--suunto-white);
            border: 2px solid var(--suunto-card);
            border-radius: 22px;
            box-shadow: 0 2px 12px 0 rgba(0,0,0,0.18);
            margin-bottom: 0;
            padding: 0 0 32px 0;
            width: 100%;
            max-width: 600px;
            margin-left: auto;
            margin-right: auto;
            position: relative;
            box-sizing: border-box;
            transform: translateZ(0);
            -webkit-transform: translateZ(0);
            backface-visibility: hidden;
            -webkit-backface-visibility: hidden;
        }
        .checkpoint.next {
            border-left: 6px solid var(--suunto-orange);
            box-shadow: 0 4px 16px 0 rgba(255,75,0,0.13);
        }
        .checkpoint.completed {
            border-color: var(--suunto-card);
            box-shadow: 0 2px 12px 0 rgba(0,0,0,0.18);
        }
        .checkpoint-header {
            padding: 28px 28px 0 28px;
            width: 100%;
            text-align: left;
            border-bottom: 1px solid var(--suunto-card);
            display: block;
        }
        .checkpoint-name {
            font-size: 1.5em;
            font-weight: 800;
            color: var(--suunto-white);
            margin-bottom: 2px;
            letter-spacing: 0.01em;
            line-height: 1.2;
        }
        .checkpoint-mile {
            font-size: 1.13em;
            font-weight: 600;
            color: var(--suunto-gray);
            margin-bottom: 0;
            display: block;
        }
        .checkpoint-time {
            color: var(--suunto-gray);
            font-size: 1.08em;
            font-weight: 600;
            margin: 10px 0 0 0;
            line-height: 1.5;
        }
        .checkpoint-details {
            margin-top: 0;
            width: 100%;
            padding: 0 28px 0 28px;
        }
        .checkpoint-position {
            margin: 18px 0 0 0;
            font-size: 1.13em;
            font-weight: 700;
            width: 100%;
            text-align: left;
            display: flex;
            align-items: center;
            gap: 8px;
            color: var(--suunto-white);
            background: var(--suunto-card);
            padding: 10px;
            border-radius: 8px;
        }
        .checkpoint-position .icon {
            font-size: 1.2em;
            margin-right: 4px;
        }

        /* ===== SECTIONS ===== */
        .section {
            margin-top: 18px;
            padding: 18px 0 0 0;
            background: none;
            border-radius: 0;
            box-shadow: none;
        }
        .section-title {
            font-size: 1.13em;
            font-weight: 700;
            color: var(--suunto-blue);
            margin-bottom: 8px;
            letter-spacing: 0.01em;
        }
        .section-list {
            list-style-type: disc;
            margin: 0 0 0 22px;
            padding: 0;
            font-size: 1.08em;
            line-height: 1.4;
        }
        .section-list li {
            margin: 3px 0;
            font-size: 1.08em;
            text-align: left;
            white-space: normal;
            color: var(--suunto-white);
            line-height: 1.4;
        }
        .section-list li .icon {
            font-size: 1.1em;
            margin-right: 4px;
            color: var(--suunto-orange);
        }
        .task-list, .exchange-list, .pace-info {
            list-style-type: none;
            margin: 0;
            padding: 0;
            font-size: 1.08em;
            line-height: 1.4;
        }
        [contenteditable="true"] {
            outline: none;
            border: none;
            padding: 4px 0;
            margin: 0;
        }
        [contenteditable="true"]:focus {
            outline: none;
        }
        [contenteditable="true"]:hover {
            outline: none;
        }
        .task-list li, .exchange-list li, .pace-info p {
            margin: 3px 0;
            font-size: 1.08em;
            text-align: left;
            white-space: normal;
            color: var(--suunto-white);
            line-height: 1.4;
            padding-left: 0;
        }
        .exchange-list li .icon {
            font-size: 1.1em;
            margin-right: 4px;
            color: var(--suunto-orange);
        }

        /* ===== BUTTONS ===== */
        .checkpoint-controls {
            display: flex;
            flex-direction: column;
            gap: 0;
            margin: 18px 0 0 0;
            padding: 0;
            border: none;
            width: 100%;
        }
        .checkpoint-button {
            width: 100%;
            font-size: 1.18em;
            padding: 18px 0;
            border-radius: 20px;
            font-weight: 800;
            box-shadow: 0 2px 8px 0 rgba(0,0,0,0.10);
            cursor: pointer;
            transition: background 0.15s, color 0.15s, border 0.15s, filter 0.15s;
            border: 2px solid var(--suunto-orange);
            background: var(--suunto-orange);
            color: var(--suunto-white);
        }
        .checkpoint-button:active,
        .checkpoint-button:not(.reset-button):active {
            filter: brightness(0.93);
            background: var(--suunto-orange);
            color: var(--suunto-white);
            border-color: var(--suunto-orange);
        }
        .checkpoint-button.reset-button {
            background: var(--suunto-black);
            color: var(--suunto-orange);
            border: 2px solid var(--suunto-orange);
        }
        .checkpoint-button.reset-button:active {
            background: var(--suunto-orange);
            color: var(--suunto-white);
        }
        .checkpoint-button:disabled {
            background: var(--suunto-card);
            color: var(--suunto-gray);
            border: 2px solid var(--suunto-card);
            filter: grayscale(0.5) brightness(0.95);
            cursor: not-allowed;
        }
        .checkpoint-button.complete-button {
            background: var(--suunto-orange);
            color: var(--suunto-white);
            border: 2px solid var(--suunto-orange);
            width: 100%;
            margin: 0;
            display: block;
            font-size: 1.18em;
            padding: 18px 0;
            border-radius: 20px;
            font-weight: 800;
            box-shadow: 0 2px 8px 0 rgba(0,0,0,0.10);
            cursor: pointer;
        }
        .checkpoint-button.complete-button:active {
            filter: brightness(0.93);
        }

        /* ===== MAP BUTTONS ===== */
        .map-buttons {
            display: flex;
            flex-direction: column;
            gap: 12px;
            margin: 32px 0 32px 0;
            width: 100%;
        }
        .map-buttons a {
            display: block;
            width: 100%;
            min-width: 0;
            margin: 0;
            padding: 13px 0;
            font-size: 1.08em;
            font-weight: 700;
            color: var(--suunto-blue) !important;
            background: var(--suunto-card);
            border: 2px solid var(--suunto-blue);
            border-radius: 999px;
            text-align: center;
            text-decoration: none;
            box-shadow: 0 1px 4px 0 rgba(0,0,0,0.07);
            transition: background 0.15s, color 0.15s, border 0.15s;
            letter-spacing: 0.01em;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }
        @media (hover: none) {
            .map-buttons a:hover {
                background: var(--suunto-card);
                color: var(--suunto-blue) !important;
                border-color: var(--suunto-blue);
            }
        }

        /* ===== MODALS ===== */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(24,26,27,0.92);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }
        .modal-content {
            background: var(--suunto-card);
            color: var(--suunto-white);
            padding: 38px 28px 32px 28px;
            border-radius: 22px;
            max-width: 420px;
            width: 92vw;
            text-align: center;
            font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif;
            box-shadow: 0 6px 32px 0 rgba(0,0,0,0.22);
        }
        .modal-content h3 {
            font-size: 2em;
            font-weight: 900;
            margin-bottom: 18px;
            color: var(--suunto-white);
            letter-spacing: 0.01em;
        }
        .modal-content p {
            font-size: 1.18em;
            color: var(--suunto-white);
            margin-bottom: 28px;
            line-height: 1.6;
            font-weight: 500;
        }
        .modal-buttons {
            display: flex;
            gap: 10px;
            margin-top: 18px;
            justify-content: center;
            width: 100%;
            flex-wrap: wrap;
        }
        .modal-button {
            padding: 16px 0;
            border-radius: 16px;
            font-weight: 800;
            font-size: 1.18em;
            border: 2px solid var(--suunto-orange);
            background: var(--suunto-black);
            color: var(--suunto-orange);
            cursor: pointer;
            width: 100%;
            transition: background 0.15s, color 0.15s, border 0.15s;
            margin-bottom: 0;
        }
        .modal-button.confirm-button {
            background: var(--suunto-orange);
            color: var(--suunto-white);
            border: 2px solid var(--suunto-orange);
            font-weight: 900;
        }
        .modal-button.cancel-button {
            background: var(--suunto-black);
            color: var(--suunto-orange);
            border: 2px solid var(--suunto-orange);
            font-weight: 800;
        }
        .modal-button.cancel-button:active {
            background: var(--suunto-orange);
            color: var(--suunto-white);
        }
        #checkpointResetModal {
            z-index: 1100;
        }

        /* ===== TIMELINE ===== */
        #timeline {
            margin-top: 48px;
            margin-bottom: 32px;
            width: 100%;
            max-width: 600px;
            margin-left: auto;
            margin-right: auto;
            padding: 24px 18px 24px 24px;
        }
        .timeline-outer {
            width: 100%;
            padding: 0 0 0 0;
        }
        .timeline-list {
            list-style: none;
            margin: 0;
            padding: 0 0 0 12px;
            border-left: 3px solid var(--suunto-card);
        }
        .timeline-item {
            display: flex;
            align-items: center;
            margin-bottom: 24px;
            position: relative;
            min-height: 18px;
            cursor: pointer;
            transition: opacity 0.15s;
        }
        .timeline-item:hover {
            opacity: 0.8;
        }
        .timeline-dot {
            width: 16px;
            height: 16px;
            background: var(--suunto-card);
            border: 3px solid var(--suunto-orange);
            border-radius: 50%;
            position: absolute;
            left: -21px;
            top: 50%;
            transform: translateY(-50%);
            z-index: 2;
        }
        .timeline-item.checked-in .timeline-dot {
            background: var(--suunto-orange);
        }
        .timeline-item.current .timeline-dot {
            border-color: var(--suunto-blue);
            box-shadow: 0 0 0 4px rgba(0,144,255,0.18);
        }
        .timeline-label {
            flex: 1;
            font-size: 1.08em;
            color: var(--suunto-white);
            font-weight: 700;
            margin-left: 12px;
        }
        .timeline-time {
            font-size: 1em;
            color: var(--suunto-gray);
            font-weight: 600;
            margin-left: 18px;
            min-width: 90px;
            text-align: right;
        }
        .timeline-item.current .timeline-label {
            color: var(--suunto-blue);
        }
        .timeline-item.current .timeline-time {
            color: var(--suunto-blue);
        }

        /* ===== MOBILE STYLES ===== */
        @media (max-width: 600px) {
            header {
                padding: 8px 0 4px 0;
            }
            h1 {
                font-size: 1.18em;
                margin-bottom: 6px;
            }
            .modal-content h3 {
                font-size: 1.5em;
                margin-bottom: 12px;
            }
            .modal-content p {
                font-size: 1.08em;
                margin-bottom: 20px;
                line-height: 1.4;
            }
            .modal-button {
                font-size: 1.18em;
                padding: 16px 0;
                min-height: 52px;
            }
            .race-timer {
                width: 100%;
                max-width: 100%;
                font-size: 1.5em;
                padding: 10px 0 10px 0;
                margin-bottom: 10px;
                box-sizing: border-box;
            }
            .checkpoint {
                border-radius: 10px;
                padding: 8px 0 2px 0;
                width: 100%;
                max-width: 100%;
                box-sizing: border-box;
            }
            .checkpoint-header {
                padding: 8px 12px 4px 12px;
                margin-bottom: 2px;
            }
            .checkpoint-details {
                padding: 0 12px 4px 12px;
            }
            .goal-times {
                padding: 0 12px 0 12px;
                margin-bottom: 0;
            }
            .checkpoint-name {
                font-size: 1.25em;
                margin-bottom: 2px !important;
            }
            .checkpoint-time {
                font-size: 0.93em;
                margin-bottom: 2px;
            }
            .goal-times {
                margin-top: 4px;
            }
            .section {
                margin-top: 4px;
                padding-top: 12px;
            }
            .section-title {
                font-size: 0.97em;
                margin-bottom: 2px;
                margin-top: 0;
            }
            .section-list, .task-list, .exchange-list, .pace-info {
                font-size: 0.93em;
                line-height: 1.4;
                margin-bottom: 4px;
                margin-top: 0;
            }
            .section-list li, .task-list li, .exchange-list li, .pace-info p {
                font-size: 0.93em;
                line-height: 1.4;
                margin-bottom: 3px;
            }
            .map-buttons {
                margin: 32px 0 32px 0;
                gap: 4px;
            }
            .map-buttons a {
                font-size: 1.08em;
                padding: 12px 0;
                margin-bottom: 2px;
            }
            .map-buttons a + a {
                margin-top: 2px;
            }
            .checkpoint-button, .modal-button {
                font-size: 0.97em;
                min-height: 44px;
                padding: 12px 0;
                border-radius: 10px;
            }
            .pace-info, .pace-badge {
                font-size: 0.93em;
                padding: 0 0 2px 0;
                margin-bottom: 0;
            }
            #timeline {
                padding: 12px 6px 12px 12px;
                margin-top: 10px;
                margin-bottom: 14px;
            }
            .timeline-label { 
                font-size: 0.90em; 
            }
            .timeline-time { 
                font-size: 0.88em; 
                min-width: 54px; 
            }
            .timeline-dot { 
                width: 10px; 
                height: 10px; 
                left: -8px; 
            }
            .timeline-list { 
                padding-left: 2px; 
            }
            .timeline-item { 
                margin-bottom: 16px; 
                min-height: 28px; 
            }
            .section {
                margin-top: 4px;
            }
            .checkpoint-controls,
            .finish-controls {
                margin-bottom: 18px;
            }
            
            /* Touch feedback for all buttons */
            .checkpoint-button:active,
            .map-buttons a:active,
            .modal-button:active {
                opacity: 0.85;
                filter: brightness(0.95);
            }
            
            /* Keep orange buttons solid on focus */
            .checkpoint-button.complete-button:focus,
            .checkpoint-button:not(.reset-button):focus {
                background: var(--suunto-orange);
                color: var(--suunto-white);
                border-color: var(--suunto-orange);
                outline: none;
            }
            
            /* Remove focus states for other elements */
            .map-buttons a:focus,
            .modal-button:focus,
            button:focus,
            a:focus {
                outline: none;
            }
            
            /* Reset button specific focus state */
            .checkpoint-button.reset-button:focus {
                background: var(--suunto-black);
                color: var(--suunto-orange);
                border-color: var(--suunto-orange);
                outline: none;
            }
        }

        /* ===== MODAL SPECIFIC STYLES ===== */
        #timelineModal .modal-content {
            max-height: 90vh;
            overflow-y: auto;
            text-align: left;
        }
        #timelineModal .section-title {
            text-align: left;
        }
        #timelineModal .checkpoint-header {
            text-align: left;
        }
        #timelineModal .checkpoint-name {
            text-align: left;
        }
        #timelineModal .checkpoint-time {
            text-align: left;
        }
        #timelineModal .goal-times {
            text-align: left;
        }
        #timelineModal .pace-info {
            text-align: left;
        }
        #timelineModal .checkpoint-controls:empty {
            margin: 0;
            display: none;
        }
    </style>
    <script>
        // Register service worker
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('https://jfornear.s3.us-west-2.amazonaws.com/tws/sw.js')
                    .then(registration => {
                        console.log('ServiceWorker registration successful');
                    })
                    .catch(err => {
                        console.log('ServiceWorker registration failed: ', err);
                    });
            });
        }
    </script>
</head>
<body>
    <header>
        <div style="max-width: 600px; margin: 0 auto; padding: 0;">
            <h1>Texas Water Safari 2025</h1>
            <!-- <p>Team Captain Checkpoints</p> -->
            <div class="race-controls">
                <button class="checkpoint-button start-race-button" id="startRace">Start</button>
                <button class="checkpoint-button reset-button" id="resetRace">Reset</button>
            </div>
            <div class="race-timer" id="raceTimer">00:00:00:00</div>
        </div>
    </header>

    <div id="resetConfirmModal" class="modal">
        <div class="modal-content">
            <h3>Reset Race?</h3>
            <p>This will clear all checkpoint times and race data. This action cannot be undone.</p>
            <div class="modal-buttons">
                <button class="modal-button confirm-button" id="confirmReset">Yes, Reset Race</button>
                <button class="modal-button confirm-button" id="confirmResetWithEdits">Reset Race & Clear Edits</button>
                <button class="modal-button cancel-button" id="cancelReset">Cancel</button>
            </div>
        </div>
    </div>

    <div id="checkpointResetModal" class="modal">
        <div class="modal-content">
            <h3>Reset Checkpoint?</h3>
            <p>This will undo the check-in for this checkpoint. This action cannot be undone.</p>
            <div class="modal-buttons">
                <button class="modal-button confirm-button" id="confirmCheckpointReset">Yes, Reset Checkpoint</button>
                <button class="modal-button cancel-button" id="cancelCheckpointReset">Cancel</button>
            </div>
        </div>
    </div>

    <div id="checkpoints">
        <!-- Checkpoints will be dynamically populated here -->
    </div>

    <div id="timeline" style="max-width:600px;margin:32px auto;"></div>

    <!-- Add modal for timeline navigation -->
    <div id="timelineModal" class="modal">
        <div class="modal-content" style="max-width: 600px; width: 92vw; padding: 0;">
            <div id="modalCheckpoint"></div>
        </div>
    </div>

    <script>
        // Race Configuration
        const RACE_CONFIG = {
            // Set to true to use current date/time for testing
            useCurrentTime: true,
            // Race date and time (only used if useCurrentTime is false)
            raceDate: '2025-06-13',
            raceTime: '09:00:00',
            // Timezone for the race
            timezone: 'America/Chicago'
        };

        // Calculate race start time based on configuration
        function getRaceStartTime() {
            if (RACE_CONFIG.useCurrentTime) {
                // For testing: Use current time
                return new Date();
            } else {
                // For actual race: Use configured date and time
                return new Date(`${RACE_CONFIG.raceDate}T${RACE_CONFIG.raceTime}-05:00`);
            }
        }

        const RACE_START = getRaceStartTime();
        let raceStarted = false;
        let raceStartTime = null;
        let timerInterval = null;
        
        // Helper functions for timezone handling
        function toUTC(date) {
            return new Date(date.getTime() - (date.getTimezoneOffset() * 60000));
        }

        function fromUTC(utcDate) {
            return new Date(utcDate.getTime() + (utcDate.getTimezoneOffset() * 60000));
        }

        function formatTime(date) {
            return date.toLocaleTimeString('en-US', { 
                hour: 'numeric', 
                minute: '2-digit',
                hour12: true,
                timeZone: RACE_CONFIG.timezone
            });
        }

        function formatDate(date, day = null) {
            if (day) {
                return day;
            }
            return date.toLocaleDateString('en-US', {
                weekday: 'short',
                month: 'short',
                day: 'numeric',
                year: 'numeric',
                timeZone: RACE_CONFIG.timezone
            });
        }

        const checkpoints = [
            {
                name: "Aquarena Springs - RACE START",
                mile: "1",
                time: "Fri 9:00 AM",
                position: "The Meadows Center, Spring Lake, San Marcos, TX",
                directions: "Exit IH-35 (Exit 206) at Aquarena Springs Drive (TX 82). Travel west on Aquarena Springs Drive. Stay to the right and do not get on the overpass. At the stoplight, take a left on 140 and then a right on Post Rd/Laurel St. Directly across from Bobcat Stadium. Pass through golf course.<br><br>PARKING: some parking is available in the parking lots once you pass through the golf course although it will fill up. Space is set up to drop off boats/gear and then park in surrounding lots. Alternate parking is available across Hwy 80 in the Campus parking lots. Shuttles typically from nearby parking lots to Aquarina Springs.",
                exchange: ["Be at boats by 8:00 AM", "Each man has 1 food pack, 2 ice water jugs"],
                isStart: true,
                maps: {
                    google: "https://maps.google.com/?q=201+San+Marcos+Springs+Dr,+San+Marcos,+TX+78666",
                    apple: "https://maps.apple.com/?q=201+San+Marcos+Springs+Dr,+San+Marcos,+TX+78666"
                }
            },
            {
                name: "Staples - CHECKPOINT 1",
                mile: "17",
                time: "Fri ~12:30 PM (Deadline 2:00 PM)",
                position: "River RIGHT below the dam, on the rocks",
                directions: "Return to Hwy 80 and turn right. Travel (3.4 mi.) on Hwy 80 to FM 1977, turn Right. 2.3 mi. to bridge.<br>Teams will portage both river left and river right. TC's - know which side your team is going to portage. Official Checkpoint will be on river right, don't forget to sign out your team.<br>Best spectator viewing is on river right. The owners are very hospitable to TWS so please be considerate. Parking is tight, prepare to walk and carry items.",
                exchange: ["1W (×2)", "1 ice pack (×2)", "MG Spiz"],
                napTime: "30 min",
                maps: {
                    google: "https://maps.google.com/?q=29.782312,-97.83131",
                    apple: "https://maps.apple.com/?q=29.782312,-97.83131"
                }
            },
            {
                name: "Fentress",
                mile: "26",
                time: "Fri ~3:00 PM",
                position: "River LEFT on the beach",
                directions: "Return to Hwy 80, turn right.<br>Travel 3.6 mi to FM 20 and turn right. (There is a flashing yellow light and a Valero gas station at turn.)<br>Turn right on Hwy 20 to bridge.<br>Amigo's beach is on river left - you can pay to park in their parking lot or TCKRA members with a parking sticker can park for free.<br>You can also access by taking HWY 621 to HWY 20 which will take you into Fentress. Amigo's beach will be on the right after crossing the river.",
                exchange: ["1W (×2)", "1F (×2)", "1 ice pack (×2)"],
                napTime: "45 min",
                maps: {
                    google: "https://maps.google.com/?q=13701+State+Park+Rd,+Fentress,+TX+78622",
                    apple: "https://maps.apple.com/?q=13701+State+Park+Rd,+Fentress,+TX+78622"
                }
            },
            {
                name: "Stairtown",
                mile: "33",
                time: "Fri ~4:30 PM",
                position: "River LEFT under the bridge",
                directions: "Back to Hwy 80. Turn right (1.8 mi.) to CR119/ Stairtown Road (NOT Stairtown Loop).<br>Turn right (.8 mi.) to bridge.<br>Park on the road. Viewing possible from bridge.<br>Access river from either side directly under the bridge.<br>Do NOT follow the dirt road down to the gravel bar. Private property and TWS does not have approval to access.",
                exchange: ["1W (×2)"],
                napTime: "30 min",
                maps: {
                    google: "https://maps.google.com/?q=29.712696,-97.738347",
                    apple: "https://maps.apple.com/?q=29.712696,-97.738347"
                }
            },
            {
                name: "Luling HWY 90 - CHECKPOINT 2",
                mile: "40",
                time: "Fri ~6:00 PM (Deadline 8:00 PM)",
                position: "River LEFT on beach",
                directions: "Return to Hwy 80 and turn Right. Travel into Luling. Turn right at stop light onto HWY 183. Turn right at stop light onto HW 90 West. (There are several shortcuts through town.)<br>Drive 2.6 miles on on HWY 90 to picnic area. Look for sign saying 1 mile to picnic area. Turn left before the bridge (Paddling Trail) - easy to miss. It's the first left after leaving town.<br>Go under bridge, stay left, go under bridge again, continue down to river.<br>There is no shade and will be busy with locals and spectators hanging out for the day. Expect a crowd. Parking will be tight, be prepared to walk.",
                exchange: ["1W (×2)", "1F (×2)", "MG Spiz"],
                napTime: "90 min",
                maps: {
                    google: "https://maps.google.com/?q=29.667722,-97.69978",
                    apple: "https://maps.apple.com/?q=29.667722,-97.69978"
                }
            },
            {
                name: "Luling Dam/Zedler Mill",
                mile: "46",
                time: "Fri ~7:30 PM",
                position: "Meet in water below the dam for exchange, river RIGHT",
                directions: "Return to HWY 90 and turn right (heading back into town), travel 2.6 mi. to Hwy 80. Turn right onto HWY 80.<br>Cross the bridge and turn right (signs for Texas Paddling Trail). Teams will portage on the river right.<br>Zedler Mill is on the right (Laurel Street) before the bridge and is good for spectator viewing.",
                exchange: ["2W (×2)", "Night prep: Attach light and sleep sling"],
                napTime: "30 min",
                maps: {
                    google: "https://maps.google.com/?q=29.666222,-97.651944",
                    apple: "https://maps.apple.com/?q=29.666222,-97.651944"
                }
            },
            {
                name: "Palmetto State Park - CHECKPOINT 3",
                mile: "60",
                time: "Fri ~11:00 PM (Deadline 6:00 AM Saturday)",
                position: "River RIGHT, watch other teams, decide run or portage bridge",
                directions: "Park pass is needed - purchase a park pass at race check-in or stop at the entrance to pay for day pass.<br>Go back into Luling on Hwy 80 and turn right onto Hwy 90/183.<br>OR - go south on 80 to I-10, head East on I-10 one exit to 183.<br>Go to Park Road 11, turn right (Stone wall/entrance to State Park) or keep going to 261 (both end up on the same spot).<br>Look for 'Palmetto State Park 1 mile ahead' signs along Hwy 90/183.<br>Park Headquarters will be on Right - cross 3 bridges, to second PR 11 sign.<br>Turn left take PR 11 for (.5 mi).<br>Note: Follow signs or park personnel - bridge may be accessed from both sides of the river. If parking is full on one side you may be directed to the other parking area.",
                exchange: ["2W (×2)", "1F (×2)", "MG Spiz", "Prep: Attach sleep sling. MG and MR should each try and sleep an hour while other paddles."],
                napTime: "120 min",
                maps: {
                    google: "https://maps.google.com/?q=29.589361,-97.583972",
                    apple: "https://maps.apple.com/?q=29.589361,-97.583972"
                }
            },
            {
                name: "Gonzales Dam - CHECKPOINT 4",
                mile: "84",
                time: "Sat ~7:00 AM (Deadline 2:00 PM)",
                position: "River LEFT above the dam, walk with us as it's a long portage to below the dam",
                directions: "Back to light at the intersection of Hwy 90A and Hwy 183.<br>Turn right on Hwy 183.<br>Continue about 1.3 miles. Dam will be on your right. Parking is located at the first right after the dam (parking for soccer/baseball fields).<br>Be prepared to carry supplies for team from parking to the dam.",
                exchange: ["4W (×2)", "1LF (×2)", "2 ice packs (×2)", "Prep: Take off sleep sling. Take off light, make sure it is charging."],
                napTime: "90 min",
                maps: {
                    google: "https://maps.google.com/?q=29.483333,-97.448333",
                    apple: "https://maps.apple.com/?q=29.483333,-97.448333"
                }
            },
            {
                name: "Hochheim - CHECKPOINT 5",
                mile: "123",
                time: "Sat ~3:00 PM (Deadline 4:00 AM Sunday)",
                position: "Slope is steep down to river",
                directions: "From Gonzales 183 Checkpoint turn right on Hwy 183.<br>Go (16 mi) to the bridge, turn off on your left just before the Guadalupe River Bridge (small drive next to bridge). Proceed beside bridge and approximately 20 yards before reaching the river, there is a metal gate on the left. Turn left through the gate and drive, parallel to the river, for approx. 200 yards to the checkpoint on the right.",
                exchange: ["2W (×2)", "1F (×2)", "Consider fresh food from a restaurant as above"],
                napTime: "90 min",
                maps: {
                    google: "https://maps.google.com/?q=29.316972,-97.306306",
                    apple: "https://maps.apple.com/?q=29.316972,-97.306306"
                }
            },
            {
                name: "Cheapside - CHECKPOINT 6",
                mile: "148",
                time: "Sat ~11:00 PM (Deadline 11:00 AM Sunday)",
                position: "",
                directions: "From Hochheim bridge turn left on Hwy 183.<br>Go towards Cuero and turn right on Old Gonzales Road.<br>Left on 108, Right on 124 and then Right on 77.<br>Go to gravel road past bridge, turn right under bridge.<br><br>Alt path: Go north on 183 and turn left on 77.",
                exchange: ["2W (×2)", "1F (×2)", "MG Spiz", "Prep: attach sleep sling and light"],
                napTime: "120 min",
                maps: {
                    google: "https://maps.google.com/?q=29.147265,-97.317855",
                    apple: "https://maps.apple.com/?q=29.147265,-97.317855"
                }
            },
            {
                name: "Cuero HWY 236 - CHECKPOINT 7",
                mile: "160",
                time: "Sun ~4:00 AM (Deadline 3:00 PM)",
                position: "",
                directions: "From Cheapside or FM 72 - travel back into Cuero.<br>Go through town to light at (Morgan St./Arneckville), turn east on E. Morgan Ave.<br>Follow E. Morgan Ave. for (.5 mi) to FM 236/Arneckville Road.<br>Turn right and go (2.5 mi.) to bridge.<br>Exit right on gravel road before bridge.",
                exchange: ["2W (×2)", "1F (×2)", "Prep: remove sleep sling, remove light and make sure it is charging"],
                napTime: "90 min",
                maps: {
                    google: "https://maps.google.com/?q=29.051293,-97.265117",
                    apple: "https://maps.apple.com/?q=29.051293,-97.265117"
                }
            },
            {
                name: "Thomaston Bridge",
                mile: "178",
                time: "Sun ~9:30 AM",
                position: "River right, it is steep to river",
                directions: "Follow FM236 to CR 418 - use caution at night, narrow roads and limited street sign's.<br><br>Alt Route:<br>Go back to Hwy 183, turn right.<br>Proceed (.3 mi.) to Hwy 87, turn right on Hwy 87.<br>Go (11.8 mi) to Thomaston River Road, turn right (2.3 mi.) to bridge. Cross bridge and park on either side.<br><br>Note: Steep river access. A rope may be necessary to access the river.",
                exchange: ["2W (×2)", "1F (×2)", "1 ice pack (×2)", "MG Spiz"],
                napTime: "45 min",
                maps: {
                    google: "https://maps.google.com/?q=28.974278,-97.188722",
                    apple: "https://maps.apple.com/?q=28.974278,-97.188722"
                }
            },
            {
                name: "Victoria City Park - CHECKPOINT 8",
                mile: "200",
                time: "Sun ~2:00 PM (Deadline 6:00 AM Monday)",
                position: "In the water, at the boat ramp",
                directions: "From Nursery FM 447, go back to Hwy 87, turn right.<br>Go (8.9 mi) to Magnolia Street (Easy to miss, 3rd right after Crestwood stop light, no stoplight at Magnolia).<br>Turn right on Magnolia and go straight (.4 mi) into Victoria City Park past Little League Complex.<br>Go past the playground complex. When you reach the Victoria Memorial Rose Garden on your left, turn right (down the hill) into parking area at boat ramp and checkpoint. Parking can be tight.",
                exchange: ["3W (×2)", "1F (×2)", "1 ice pack (×2)"],
                napTime: "90 min",
                maps: {
                    google: "https://maps.google.com/?q=28.824706,-97.01542",
                    apple: "https://maps.apple.com/?q=28.824706,-97.01542"
                }
            },
            {
                name: "Swinging Bridge - CHECKPOINT 9",
                mile: "228",
                time: "Sun ~8:00 PM (Deadline 4:00 PM Monday)",
                position: "Access is river left, be there",
                directions: "Take Hwy 59 back to Hwy 185 (Victoria/Bloomington Exit), turn right. Go to 1432 and turn right (Conoco Gas station). When road ends at gates, turn right. When paved road turns right, stay straight on gravel road (will loop left around plant). Follow gravel road for aprox 3 miles. Be sure to close any gates you open. Checkpoint will be located at the boat ramp on INVISTA property. NOTE: Swinging Bridge is owned by Invista who controls access to the river. It is open for the race only and is not accessible for training runs.",
                exchange: ["2W (×2)", "1F (×2)", "Prep: Attach sleep sling and light"],
                napTime: "120 min",
                maps: {
                    google: "https://maps.google.com/?q=28.651783,-96.962229",
                    apple: "https://maps.apple.com/?q=28.651783,-96.962229"
                }
            },
            {
                name: "Papa & Maga / Calhoun Tivoli - CHECKPOINT 10",
                mile: "251",
                time: "Mon ~3:00 AM (Deadline 3:00 AM Tuesday)",
                position: "Boat ramp with dock next to it, can be in water at ramp or on the dock",
                directions: "Return to Hwy 185 the way you came in. Go (13.5 mi) to intersection with Hwy 35, turn right. Take Hwy 35 towards Tivoli. Take a left on the last road right before the bridge.",
                exchange: ["2W (×2)", "1F (×2)", "MG Spiz"],
                napTime: "90 min",
                maps: {
                    google: "https://maps.google.com/?q=28.476484,-96.861536",
                    apple: "https://maps.apple.com/?q=28.476484,-96.861536"
                }
            },
            {
                name: "Seadrift - RACE FINISH",
                mile: "260",
                time: "",
                position: "Swan Point Park",
                directions: "SWAN POINT: Return to Hwy 35 and back to HWY 183. After passing through Seadrift, turn right on Gates road and left on Old Settlement Road. Turn right on Swan Point Road and follow it all the way to Swan Point Park. FINISH LINE: Once the team crosses the bouy they are done. Meaning anyone can now hug them, help with their boat (in fact please help, they have paddled 260 miles and are tired), help them walk up the ramp, etc. There are oyster's in the water at the finish line - please wear shoes! Reminders: Please do not set up chairs in front of or around the finish sign. Finishers have worked hard to get to that sign and we want to give them the space for their pictures. Please try not to park or block the road between the ramp and the finish sign (even when loading boats.)",
                exchange: [],
                napTime: "",
                maps: {
                    google: "https://maps.google.com/?q=28.4146,-96.7131",
                    apple: "https://maps.apple.com/?q=28.4146,-96.7131"
                },
                isFinish: true
            }
        ];

        // Update goal times for new categories
        const checkpointGoals = {
            "Aquarena Springs - RACE START": {mile: 0, time: "9:00 AM", day: "Fri"},
            "Staples - CHECKPOINT 1": {mile: 17, time: "12:50 PM", day: "Fri"},
            "Fentress": {mile: 26, time: "3:00 PM", day: "Fri"},
            "Stairtown": {mile: 33, time: "4:39 PM", day: "Fri"},
            "Luling HWY 90 - CHECKPOINT 2": {mile: 40, time: "6:09 PM", day: "Fri"},
            "Luling Dam/Zedler Mill": {mile: 46, time: "7:31 PM", day: "Fri"},
            "Palmetto State Park - CHECKPOINT 3": {mile: 60, time: "10:54 PM", day: "Fri"},
            "Gonzales Dam - CHECKPOINT 4": {mile: 84, time: "4:30 AM", day: "Sat"},
            "Hochheim - CHECKPOINT 5": {mile: 123, time: "1:18 PM", day: "Sat"},
            "Cheapside - CHECKPOINT 6": {mile: 148, time: "7:02 PM", day: "Sat"},
            "Cuero HWY 236 - CHECKPOINT 7": {mile: 160, time: "10:13 PM", day: "Sat"},
            "Thomaston Bridge": {mile: 178, time: "2:08 AM", day: "Sun"},
            "Victoria City Park - CHECKPOINT 8": {mile: 200, time: "7:09 AM", day: "Sun"},
            "Swinging Bridge - CHECKPOINT 9": {mile: 228, time: "2:24 PM", day: "Sun"},
            "Papa & Maga / Calhoun Tivoli - CHECKPOINT 10": {mile: 251, time: "6:02 PM", day: "Sun"},
            "Seadrift - RACE FINISH": {mile: 260, time: "9:02 PM", day: "Sun"}
        };

        // Helper to get new goal times for a checkpoint
        function getGoalTimes(name, currentPace) {
            const totalMiles = 260; // Total race distance
            const hoursToFinish = totalMiles / currentPace;
            const finishDate = new Date(RACE_START.getTime() + (hoursToFinish * 60 * 60 * 1000));
            
            return `
                <div class="section" style="margin-top:8px;">
                    <div class="section-title">Pace</div>
                    <ul class="exchange-list">
                        <li><span style="color:var(--suunto-white);font-weight:700;">${currentPace.toFixed(1)} mph</span></li>
                    </ul>
                </div>
            `;
        }

        function calculatePace(startMile, endMile, startTime, endTime) {
            const miles = endMile - startMile;
            const hours = (endTime - startTime) / (1000 * 60 * 60);
            return miles / hours;
        }

        function estimateNextTime(currentMile, nextMile, currentTime, pace) {
            const milesToNext = nextMile - currentMile;
            const hoursToNext = milesToNext / pace;
            return new Date(currentTime.getTime() + (hoursToNext * 60 * 60 * 1000));
        }

        // Add helper function to calculate day based on hours from race start
        function calculateDayFromHours(hoursFromStart) {
            // Use the actual race start date (June 13, 2025) which is a Friday
            const raceStartDay = 5; // Friday (0 = Sunday, 5 = Friday)
            const totalDays = Math.floor(hoursFromStart / 24);
            const dayOffset = (raceStartDay + totalDays) % 7;
            
            // Map day numbers to our race days
            const dayMap = {
                5: 'Fri', // Friday
                6: 'Sat', // Saturday
                0: 'Sun', // Sunday
                1: 'Mon'  // Monday
            };
            
            return dayMap[dayOffset] || 'Mon'; // Default to Mon if somehow outside our range
        }

        // Update the calculateEstimatedArrival function to include day calculation
        function calculateEstimatedArrival(mile, currentPace) {
            if (!raceStarted) {
                // If race hasn't started, use the time chart times
                const cpGoal = checkpointGoals[checkpoints.find(cp => parseFloat(cp.mile) === mile)?.name];
                if (cpGoal) {
                    const [time, period] = cpGoal.time.split(' ');
                    const [hours, minutes] = time.split(':').map(Number);
                    let hour = hours;
                    if (period === 'PM' && hours !== 12) hour += 12;
                    if (period === 'AM' && hours === 12) hour = 0;
                    
                    const goalDate = new Date(RACE_START);
                    goalDate.setHours(hour, minutes, 0, 0);
                    return { time: goalDate, pace: 4.3, day: cpGoal.day };
                }
            }

            // Get the last completed checkpoint
            const completed = JSON.parse(localStorage.getItem('completedCheckpoints') || '[]');
            const lastCompleted = completed[completed.length - 1];
            
            if (!lastCompleted) {
                // If no checkpoints completed, use race start time
                const hoursFromStart = mile / currentPace;
                const arrival = new Date(RACE_START.getTime() + (hoursFromStart * 60 * 60 * 1000));
                const day = calculateDayFromHours(hoursFromStart);
                return { time: arrival, pace: currentPace, day };
            }

            // Calculate time based on last checkpoint
            const lastMile = parseFloat(lastCompleted.mile);
            const lastTime = new Date(lastCompleted.completionTime);
            const milesToGo = mile - lastMile;
            const hoursToGo = milesToGo / currentPace;
            const arrival = new Date(lastTime.getTime() + (hoursToGo * 60 * 60 * 1000));
            
            // Calculate total hours from race start
            const totalHoursFromStart = (arrival - RACE_START) / (1000 * 60 * 60);
            const day = calculateDayFromHours(totalHoursFromStart);
            
            return { time: arrival, pace: currentPace, day };
        }

        // Update the calculateCurrentPace function to be more accurate
        function calculateCurrentPace() {
            if (!raceStarted) {
                return 4.3; // Default pace if race hasn't started
            }
            
            // Try to get saved pace first
            const savedPace = localStorage.getItem('currentPace');
            if (savedPace) {
                return parseFloat(savedPace);
            }
            
            const completed = JSON.parse(localStorage.getItem('completedCheckpoints') || '[]');
            if (completed.length < 2) {
                return 4.3; // Default pace if not enough checkpoints
            }
            
            // Calculate pace based on last two checkpoints for more accuracy
            const lastTwo = completed.slice(-2);
            const miles = parseFloat(lastTwo[1].mile) - parseFloat(lastTwo[0].mile);
            const timeDiff = (new Date(lastTwo[1].completionTime) - new Date(lastTwo[0].completionTime)) / (1000 * 60 * 60);
            
            // Ensure we don't divide by zero and have a minimum time difference
            const hours = Math.max(1/3600, timeDiff); // minimum 1 second
            const pace = miles / hours;
            
            // Save current pace to localStorage
            localStorage.setItem('currentPace', pace.toString());
            
            return pace;
        }

        function updateEstimatedTimes(lastCheckpoint) {
            if (!lastCheckpoint) return;
            
            const currentPace = calculateCurrentPace();
            const remainingCheckpoints = checkpoints.filter(cp => 
                parseFloat(cp.mile) > parseFloat(lastCheckpoint.mile)
            );
            
            remainingCheckpoints.forEach(cp => {
                const arrival = calculateEstimatedArrival(parseFloat(cp.mile), currentPace);
                const checkpointElement = document.querySelector(`[data-checkpoint="${cp.name}"]`);
                
                if (checkpointElement) {
                    // Update estimated time under checkpoint name
                    const headerTime = checkpointElement.querySelector('.checkpoint-time');
                    if (headerTime) {
                        let headerText = `Est. Arrival: ${formatDate(arrival.time)} ${formatTime(arrival.time)} (${currentPace.toFixed(1)} mph)`;
                        if (cp.time && cp.time.includes('Deadline')) {
                            const deadline = cp.time.match(/Deadline[^)]+/);
                            if (deadline) {
                                headerText += ` — ${deadline[0]}`;
                            }
                        }
                        headerTime.textContent = headerText;
                    }
                    
                    // Update pace info
                    const goalTimesDiv = checkpointElement.querySelector('.goal-times');
                    if (goalTimesDiv) {
                        const hoursToFinish = 260 / currentPace;
                        goalTimesDiv.innerHTML = `
                            <div class="section" style="margin-top:8px;">
                                <div class="section-title">Pace</div>
                                <ul class="exchange-list">
                                    <li><span style="color:var(--suunto-white);font-weight:700;">${currentPace.toFixed(1)} mph</span></li>
                                </ul>
                            </div>
                        `;
                    }
                }
            });
        }

        function formatTimer(milliseconds) {
            const hours = Math.floor(milliseconds / (1000 * 60 * 60));
            const minutes = Math.floor((milliseconds % (1000 * 60 * 60)) / (1000 * 60));
            const seconds = Math.floor((milliseconds % (1000 * 60)) / 1000);
            const centiseconds = Math.floor((milliseconds % 1000) / 10);
            
            return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}:${centiseconds.toString().padStart(2, '0')}`;
        }

        function updateTimer() {
            if (!raceStarted || !raceStartTime) return;
            
            const now = new Date();
            const elapsed = now.getTime() - raceStartTime.getTime();
            document.getElementById('raceTimer').textContent = formatTimer(elapsed);
        }

        // Helper to determine if a checkpoint is a sleep card
        function isSleepCard(checkpoint) {
            return checkpoint.name && checkpoint.name.startsWith('Optional Sleep:');
        }

        // Get completed sleep cards from localStorage
        function getCompletedSleepCards() {
            return JSON.parse(localStorage.getItem('completedSleepCards') || '[]');
        }
        function setCompletedSleepCards(arr) {
            localStorage.setItem('completedSleepCards', JSON.stringify(arr));
        }

        // Find the next actionable card (checkpoint or sleep card)
        function getNextActionableIndex(checkpoints, completed) {
            for (let i = 0; i < checkpoints.length; i++) {
                const cp = checkpoints[i];
                if (!completed.find(c => c.name === cp.name)) return i;
            }
            return -1;
        }

        // Add robust storage management functions
        function saveToLocalStorage(element) {
            try {
                const key = element.getAttribute('data-storage-key');
                if (!key) return;
                
                const content = element.innerHTML;
                // Check if content is valid HTML
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = content;
                
                // Only save if the content is valid
                if (tempDiv.innerHTML === content) {
                    localStorage.setItem(key, content);
                }
            } catch (error) {
                console.error('Error saving to localStorage:', error);
                // Optionally show a user-friendly error message
            }
        }

        function loadFromLocalStorage(element) {
            try {
                const key = element.getAttribute('data-storage-key');
                if (!key) return;
                
                const savedContent = localStorage.getItem(key);
                if (savedContent) {
                    // Validate the saved content before using it
                    const tempDiv = document.createElement('div');
                    tempDiv.innerHTML = savedContent;
                    
                    // Only use the content if it's valid HTML
                    if (tempDiv.innerHTML === savedContent) {
                        element.innerHTML = savedContent;
                    }
                }
            } catch (error) {
                console.error('Error loading from localStorage:', error);
                // Optionally show a user-friendly error message
            }
        }

        function createCheckpointElement(checkpoint, badgePace = 4.3, estimatedTime = null, completedCheckpoint = null, isNext = false) {
            const div = document.createElement('div');
            div.className = 'checkpoint';
            div.setAttribute('data-checkpoint', checkpoint.name);
            const isFinishCard = checkpoint.isFinish;
            const isStartCard = checkpoint.isStart;
            
            // Store event listeners for cleanup
            const eventListeners = [];
            
            // Add event listeners for editable elements after setting innerHTML
            const setupEditableContent = () => {
                div.querySelectorAll('[contenteditable="true"]').forEach(element => {
                    // Load saved content
                    loadFromLocalStorage(element);

                    // Save on blur
                    const blurHandler = () => {
                        saveToLocalStorage(element);
                    };
                    element.addEventListener('blur', blurHandler);
                    eventListeners.push({ element, type: 'blur', handler: blurHandler });

                    // Save on input (with debounce)
                    let timeout;
                    const inputHandler = () => {
                        clearTimeout(timeout);
                        timeout = setTimeout(() => {
                            saveToLocalStorage(element);
                        }, 500);
                    };
                    element.addEventListener('input', inputHandler);
                    eventListeners.push({ element, type: 'input', handler: inputHandler });
                });
            };

            // Cleanup function to remove event listeners
            const cleanup = () => {
                eventListeners.forEach(({ element, type, handler }) => {
                    element.removeEventListener(type, handler);
                });
                eventListeners.length = 0;
            };

            // Add cleanup to the div for later use
            div.cleanup = cleanup;

            if (isStartCard) {
                div.innerHTML = `
                    <div class="checkpoint-header">
                        <div class="checkpoint-name" style="margin-bottom: 10px;">${checkpoint.name}</div>
                        <div class="checkpoint-time">Friday, June 13, 2025 9:00 AM</div>
                    </div>
                    <div class="checkpoint-details">
                        <div class="section">
                            <div class="section-title">Tasks</div>
                            <ul class="task-list" contenteditable="true" data-storage-key="tasks">
                                <li>Position yourself at: ${checkpoint.position}</li>
                                <li>Be at your boats ready to enter the water by 8:00 AM</li>
                                <li>DO NOT ENTER THE LAKE UNTIL YOU ARE TOLD THAT IT'S OK TO DO SO</li>
                            </ul>
                        </div>
                        <div class="section">
                            <div class="section-title">Directions</div>
                            <ul class="task-list" contenteditable="true" data-storage-key="directions-${checkpoint.name}">
                                <li>${checkpoint.directions}</li>
                            </ul>
                        </div>
                        <div class="map-buttons">
                            <a class="google" href="${checkpoint.maps.google}" target="_blank">Open in Google Maps</a>
                            <a class="apple" href="${checkpoint.maps.apple}" target="_blank">Open in Apple Maps</a>
                        </div>
                        <div class="checkpoint-controls">
                            <button class="checkpoint-button complete-button" id="startRaceBtn" style="${raceStarted ? 'display:none;' : ''}">Start Race</button>
                        </div>
                    </div>
                `;
                setupEditableContent();
                
                // Add event listener for Start Race button
                const startBtn = div.querySelector('#startRaceBtn');
                if (startBtn) {
                    startBtn.addEventListener('click', () => {
                        // Start the race
                        raceStarted = true;
                        raceStartTime = new Date();
                        startRaceButton.disabled = true;
                        resetRaceButton.disabled = false;
                        
                        // Enable all stop buttons
                        document.querySelectorAll('.stop-button').forEach(button => {
                            button.disabled = false;
                        });

                        // Start timer
                        timerInterval = setInterval(updateTimer, 10);
                        updateTimer();

                        // Save race start to localStorage
                        localStorage.setItem('raceStartTime', raceStartTime.toISOString());

                        // Mark start checkpoint as completed
                        const completed = JSON.parse(localStorage.getItem('completedCheckpoints') || '[]');
                        const startCheckpoint = {
                            name: checkpoint.name,
                            mile: checkpoint.mile,
                            completionTime: raceStartTime.toISOString(),
                            pace: 0 // Initial pace is 0 since we're at the start
                        };
                        completed.push(startCheckpoint);
                        localStorage.setItem('completedCheckpoints', JSON.stringify(completed));
                        
                        // Move to next card
                        setCurrentCardIndex(getCurrentCardIndex() + 1);
                        renderCheckpoints();
                    });
                }
                return div;
            }
            
            // ... rest of existing function ...

            // Get completed checkpoints to determine if this is the last completed one
            const completed = JSON.parse(localStorage.getItem('completedCheckpoints') || '[]');
            const isLastCompleted = completed.length > 0 && completed[completed.length - 1].name === checkpoint.name;
            
            // Calculate current pace
            const currentPace = calculateCurrentPace();
            
            // Format exchange items as a stacked, left-aligned list
            const formattedExchange = [];
            let hasWater = false, hasFood = false, hasLargeFood = false, hasSpiz = false, hasIcePack = false;
            let waterCount = 0;
            
            checkpoint.exchange.forEach(item => {
                if (item.includes('LF')) hasLargeFood = true;
                else if (item.includes('F')) hasFood = true;
                if (item.includes('W')) {
                    const match = item.match(/(\d+)W/);
                    if (match) {
                        waterCount = Math.max(waterCount, parseInt(match[1], 10));
                    } else {
                        waterCount = Math.max(waterCount, 1);
                    }
                    hasWater = true;
                }
                if (item.includes('MG Spiz')) hasSpiz = true;
                if (item.includes('ice pack')) hasIcePack = true;
            });

            // Add items in the specified order
            if (hasLargeFood) formattedExchange.push('1 large food pack per paddler');
            else if (hasFood) formattedExchange.push('1 food pack per paddler');
            if (hasWater) formattedExchange.push(`${waterCount} water jug${waterCount > 1 ? 's' : ''} per paddler`);
            if (hasIcePack) formattedExchange.push('1 ice pack per paddler');
            if (hasSpiz) {
                formattedExchange.push('MG Spiz');
                formattedExchange.push('MR Tailwind');
            }

            // Add restaurant information for specific checkpoints
            let restaurantInfo = '';
            if (checkpoint.name.includes('Seadrift')) {
                restaurantInfo = 'Restaurants: La Terraza (Mexican), Bubba\'s Seafood, The Shack, T\'s Kitchen';
            }

            if (restaurantInfo) {
                formattedExchange.push(restaurantInfo);
            }

            // Create task list based on checkpoint data
            const tasks = [
                `Position: ${checkpoint.position}`,
                `Prep: ${formattedExchange.filter(item => !item.startsWith('Nearby:')).join(', ')}`,
                checkpoint.time.includes('Deadline') ? `Note: ${checkpoint.time.split('(')[1].replace(')', '')}` : null
            ].filter(Boolean);

            // Add nearby amenities to tasks if applicable
            if (checkpoint.name.includes('Luling HWY 90')) {
                tasks.push('Nearby: HEB, City Market BBQ, Subway');
            } else if (checkpoint.name.includes('Palmetto State Park')) {
                tasks.push('Nearby: Buc-ee\'s');
            } else if (checkpoint.name.includes('Victoria City Park')) {
                tasks.push('Nearby: HEB Plus, Target, Texan, Whataburger, Subway, Domino\'s, Walgreens, Urgent care, ER');
            } else if (checkpoint.name.includes('Gonzales Dam')) {
                tasks.push('Nearby: Matamoros Taco Hut (breakfast tacos)');
            } else if (checkpoint.name.includes('Cuero HWY 236')) {
                tasks.push('Nearby: La Bella Tavola (Italian)');
            }

            // Calculate estimated time for this checkpoint
            let displayTime = '--';
            if (completedCheckpoint) {
                const completionTime = new Date(completedCheckpoint.completionTime);
                displayTime = `Arrived: ${formatDate(completionTime)} ${formatTime(completionTime)} (${completedCheckpoint.pace ? completedCheckpoint.pace.toFixed(1) : '—'} mph)`;
            } else {
                const currentPace = calculateCurrentPace();
                const estimated = calculateEstimatedArrival(parseFloat(checkpoint.mile), currentPace);
                
                if (estimated) {
                    displayTime = `Est. Arrival: ${formatDate(estimated.time, estimated.day)} ${formatTime(estimated.time)} (${estimated.pace.toFixed(1)} mph)`;
                    if (checkpoint.time && checkpoint.time.includes('Deadline')) {
                        const deadline = checkpoint.time.match(/Deadline[^)]+/);
                        if (deadline) {
                            displayTime += ` — ${deadline[0]}`;
                        }
                    }
                }
            }

            if (isFinishCard) {
                // Check if race is finished
                const finished = localStorage.getItem('raceFinished');
                let finishTime = localStorage.getItem('raceFinishTime');
                let displayTime = '--';
                let finalPace = 4.3;
                const totalMiles = 260;
                const savedRaceStart = localStorage.getItem('raceStartTime');
                if (finished && finishTime && savedRaceStart) {
                    // Parse finishTime as HH:MM:SS:CC
                    const [hours, minutes, seconds, centiseconds] = finishTime.split(':').map(Number);
                    const totalHours = hours + (minutes / 60) + (seconds / 3600) + (centiseconds / 360000);
                    if (totalHours > 0) {
                        finalPace = totalMiles / totalHours;
                    }
                    // Format the finish time to match other checkpoint cards
                    const finishDate = new Date(new Date(savedRaceStart).getTime() + (totalHours * 60 * 60 * 1000));
                    displayTime = `Finished: ${formatDate(finishDate)} ${formatTime(finishDate)} (${finishTime})`;
                } else {
                    // Calculate estimated arrival based on total race distance
                    const currentPace = calculateCurrentPace();
                    const estimated = calculateEstimatedArrival(parseFloat(checkpoint.mile), currentPace);
                    if (estimated) {
                        displayTime = `Est. Arrival: ${formatDate(estimated.time, estimated.day)} ${formatTime(estimated.time)} (${estimated.pace.toFixed(1)} mph) — Deadline 1:00 PM Tuesday`;
                    }
                    finalPace = currentPace;
                }
                div.innerHTML = `
                    <div class="checkpoint-header">
                        <div class="checkpoint-name" style="margin-bottom: 10px;">Seadrift - RACE FINISH</div>
                        <div class="checkpoint-time">${displayTime}</div>
                    </div>
                    <div class="checkpoint-details">
                        ${finished ? `
                            <div class="section">
                                <div class="section-title">Final Pace</div>
                                <ul class="exchange-list">
                                    <li><span style="color:var(--suunto-white);font-weight:700;">${finalPace.toFixed(1)} mph</span></li>
                                </ul>
                            </div>
                            <div class="section">
                                <div class="section-title">Congratulations!</div>
                                <ul class="task-list" contenteditable="true" data-storage-key="congratulations">
                                    <li>You've completed the Texas Water Safari!</li>
                                    <li>Get your finisher's medal</li>
                                    <li>Take team photos</li>
                                </ul>
                            </div>
                            <div class="section">
                                <div class="section-title">Finish Line Notes</div>
                                <ul class="task-list">
                                    <li>Once the team crosses the buoy they are done</li>
                                    <li>You can now help with their boat and help them walk up the ramp</li>
                                    <li>There are oysters in the water - please wear shoes!</li>
                                    <li>Do not set up chairs in front of or around the finish sign</li>
                                    <li>Do not block the road between the ramp and finish sign</li>
                                </ul>
                            </div>
                            <div class="section">
                                <div class="section-title">Nearby Restaurants</div>
                                <ul class="task-list">
                                    <li>La Terraza (Mexican): 6:30 AM - 9:00 PM</li>
                                    <li>Bubba's Seafood: 11:00 AM - 10:00 PM (closed Monday)</li>
                                    <li>The Shack: 11:00 AM - 10:00 PM</li>
                                    <li>T's Kitchen: 11:00 AM - 8:00 PM (closed Tuesday)</li>
                                </ul>
                            </div>
                            <div class="map-buttons">
                                <a class="google" href="https://maps.google.com/?q=Bill+Sander+Memorial+Park+Seadrift+1522+Swan+Point+Rd+Seadrift+TX+77983" target="_blank">Open in Google Maps</a>
                                <a class="apple" href="https://maps.apple.com/?q=Bill+Sander+Memorial+Park+Seadrift+1522+Swan+Point+Rd+Seadrift+TX+77983" target="_blank">Open in Apple Maps</a>
                            </div>
                            <div class="checkpoint-controls">
                                <button class="checkpoint-button complete-button" onclick="shareRaceResults()">Share Results</button>
                            </div>
                        ` : `
                            <div class="section">
                                <div class="section-title">Pace</div>
                                <ul class="exchange-list">
                                    <li><span style="color:var(--suunto-white);font-weight:700;">${finalPace.toFixed(1)} mph</span></li>
                                </ul>
                            </div>
                            <div class="section">
                                <div class="section-title">Tasks</div>
                                <ul class="task-list">
                                    <li>Position yourself at: Bill Sander Memorial Park – Seadrift</li>
                                    <li>1522 Swan Point Rd, Seadrift, TX 77983</li>
                                    <li>Note: Deadline 1:00 PM Tuesday</li>
                                </ul>
                            </div>
                            <div class="section">
                                <div class="section-title">Finish Line Notes</div>
                                <ul class="task-list">
                                    <li>Once the team crosses the buoy they are done</li>
                                    <li>You can now help with their boat and help them walk up the ramp</li>
                                    <li>There are oysters in the water - please wear shoes!</li>
                                    <li>Do not set up chairs in front of or around the finish sign</li>
                                    <li>Do not block the road between the ramp and finish sign</li>
                                </ul>
                            </div>
                            <div class="section">
                                <div class="section-title">Nearby Restaurants</div>
                                <ul class="task-list">
                                    <li>La Terraza (Mexican): 6:30 AM - 9:00 PM</li>
                                    <li>Bubba's Seafood: 11:00 AM - 10:00 PM (closed Monday)</li>
                                    <li>The Shack: 11:00 AM - 10:00 PM</li>
                                    <li>T's Kitchen: 11:00 AM - 8:00 PM (closed Tuesday)</li>
                                </ul>
                            </div>
                            <div class="map-buttons">
                                <a class="google" href="https://maps.google.com/?q=Bill+Sander+Memorial+Park+Seadrift+1522+Swan+Point+Rd+Seadrift+TX+77983" target="_blank">Open in Google Maps</a>
                                <a class="apple" href="https://maps.apple.com/?q=Bill+Sander+Memorial+Park+Seadrift+1522+Swan+Point+Rd+Seadrift+TX+77983" target="_blank">Open in Apple Maps</a>
                            </div>
                        `}
                        <div class="finish-controls" style="${isNext && !finished ? '' : 'display:none;'}">
                            <button class="checkpoint-button complete-button">Finish Race</button>
                        </div>
                    </div>
                `;
                const finishBtn = div.querySelector('.checkpoint-button');
                if (finishBtn) {
                    finishBtn.addEventListener('click', () => {
                        // Stop the race
                        raceStarted = false;
                        if (timerInterval) {
                            clearInterval(timerInterval);
                            timerInterval = null;
                        }
                        // Get elapsed time
                        const now = new Date();
                        let elapsed = 0;
                        if (raceStartTime) {
                            elapsed = now - raceStartTime;
                        } else if (localStorage.getItem('raceStartTime')) {
                            elapsed = now - new Date(localStorage.getItem('raceStartTime'));
                        }
                        const finalTime = formatTimer(elapsed);
                        // Hide finish button
                        finishBtn.style.display = 'none';
                        // Save finish state
                        localStorage.setItem('raceFinished', 'true');
                        localStorage.setItem('raceFinishTime', finalTime);
                        // Update main timer
                        document.getElementById('raceTimer').textContent = finalTime;
                        // Update timeline
                        renderTimeline();
                        // Update checkpoint display
                        renderCheckpoints();
                    });
                }
                return div;
            }

            div.innerHTML = `
                <div class="checkpoint-header">
                    <div class="checkpoint-name">${checkpoint.name}</div>
                    <div class="checkpoint-time">${displayTime}</div>
                </div>
                <div class="checkpoint-details">
                    <div class="section">
                        <div class="section-title">Pace</div>
                        <ul class="exchange-list">
                            <li><span style="color:var(--suunto-white);font-weight:700;">${currentPace.toFixed(1)} mph</span></li>
                        </ul>
                    </div>
                    <div class="section">
                        <div class="section-title">Tasks</div>
                        <ul class="task-list" contenteditable="true" data-storage-key="tasks-${checkpoint.name}">
                            ${tasks.map(task => `<li>${task}</li>`).join('')}
                        </ul>
                    </div>
                    <div class="section">
                        <div class="section-title">Exchange</div>
                        <ul class="exchange-list" contenteditable="true" data-storage-key="exchange-${checkpoint.name}">
                            ${formattedExchange.map(item => `<li>${item}</li>`).join('')}
                        </ul>
                    </div>
                    <div class="section">
                        <div class="section-title">Directions</div>
                        <ul class="task-list" contenteditable="true" data-storage-key="directions-${checkpoint.name}">
                            <li>${checkpoint.directions}</li>
                        </ul>
                    </div>
                    <div class="map-buttons">
                        <a class="google" href="${checkpoint.maps.google}" target="_blank">Open in Google Maps</a>
                        <a class="apple" href="${checkpoint.maps.apple}" target="_blank">Open in Apple Maps</a>
                    </div>
                    <div class="checkpoint-controls">
                        <button class="checkpoint-button complete-button" style="${isNext ? '' : 'display:none;'}">${checkpoint.name.includes('CHECKPOINT') ? 'Check In' : 'Continue'}</button>
                        <button class="checkpoint-button reset-button" style="display:none;">Reset</button>
                    </div>
                </div>
            `;
            setupEditableContent();

            // Add click handlers
            const completeButton = div.querySelector('.complete-button');
            const resetButton = div.querySelector('.reset-button');
            const paceInfo = div.querySelector('.pace-info');

            // Show correct button on load
            if (completedCheckpoint) {
                div.classList.add('completed');
                completeButton.style.display = 'none';
                // Only show reset button if this is the last completed checkpoint
                const completed = JSON.parse(localStorage.getItem('completedCheckpoints') || '[]');
                const lastCompleted = completed[completed.length - 1];
                if (lastCompleted && lastCompleted.name === checkpoint.name) {
                    resetButton.style.display = 'inline-block';
                    resetButton.addEventListener('click', () => {
                        // Show confirmation modal
                        const modal = document.getElementById('checkpointResetModal');
                        modal.style.display = 'flex';
                        
                        // Handle confirmation
                        const confirmBtn = document.getElementById('confirmCheckpointReset');
                        const cancelBtn = document.getElementById('cancelCheckpointReset');
                        
                        const handleConfirm = () => {
                            // Remove the last completed checkpoint
                            completed.pop();
                            localStorage.setItem('completedCheckpoints', JSON.stringify(completed));
                            
                            // Remove completed class and show check-in button
                            div.classList.remove('completed');
                            completeButton.style.display = 'inline-block';
                            resetButton.style.display = 'none';
                            
                            // Update the time display back to estimated arrival
                            const cp = checkpointGoals[checkpoint.name];
                            if (cp) {
                                const hoursFromStart = cp.mile / currentPace;
                                const arrival = new Date(RACE_START.getTime() + (hoursFromStart * 60 * 60 * 1000));
                                const timeDisplay = div.querySelector('.checkpoint-time');
                                if (timeDisplay) {
                                    let displayTime = `Est. Arrival: ${formatDate(arrival)} ${formatTime(arrival)} (${currentPace.toFixed(1)} mph)`;
                                    if (checkpoint.time && checkpoint.time.includes('Deadline')) {
                                        const deadline = checkpoint.time.match(/Deadline[^)]+/);
                                        if (deadline) {
                                            displayTime += ` — ${deadline[0]}`;
                                        }
                                    }
                                    timeDisplay.textContent = displayTime;
                                }
                            }
                            
                            // Move back to this card
                            setCurrentCardIndex(checkpoints.findIndex(cp => cp.name === checkpoint.name));
                            renderCheckpoints();
                            
                            // Hide modals and remove event listeners
                            modal.style.display = 'none';
                            document.getElementById('timelineModal').style.display = 'none';
                            confirmBtn.removeEventListener('click', handleConfirm);
                            cancelBtn.removeEventListener('click', handleCancel);
                        };
                        
                        const handleCancel = () => {
                            modal.style.display = 'none';
                            confirmBtn.removeEventListener('click', handleConfirm);
                            cancelBtn.removeEventListener('click', handleCancel);
                        };
                        
                        confirmBtn.addEventListener('click', handleConfirm);
                        cancelBtn.addEventListener('click', handleCancel);
                        
                        // Close modal when clicking outside
                        modal.addEventListener('click', (e) => {
                            if (e.target === modal) {
                                handleCancel();
                            }
                        });
                    });
                } else {
                    resetButton.style.display = 'none';
                }
            } else {
                resetButton.style.display = 'none';
            }

            resetButton.addEventListener('click', (e) => {
                e.stopPropagation();
                // Only allow reset if this is the last completed checkpoint
                const completed = JSON.parse(localStorage.getItem('completedCheckpoints') || '[]');
                const lastCompleted = completed[completed.length - 1];
                if (!lastCompleted || lastCompleted.name !== checkpoint.name) return;

                // Remove from localStorage
                const index = completed.findIndex(cp => cp.name === checkpoint.name);
                if (index !== -1) {
                    completed.splice(index, 1);
                    localStorage.setItem('completedCheckpoints', JSON.stringify(completed));
                }

                // Update estimated times
                const newLastCompletedRegular = getLastCompletedRegular(completed);
                updateEstimatedTimes(newLastCompletedRegular);

                // Re-render all checkpoints
                renderCheckpoints();
            });

            completeButton.addEventListener('click', (e) => {
                e.stopPropagation();
                if (!raceStarted) return;
                // Save completion to localStorage for stats
                const completed = JSON.parse(localStorage.getItem('completedCheckpoints') || '[]');
                const now = new Date();
                // Ensure completion time is after race start
                const completionTime = now < RACE_START ? new Date(RACE_START.getTime() + 1000) : now;
                const elapsedTime = Math.max(1/3600, (completionTime - RACE_START) / (1000 * 60 * 60)); // hours, minimum 1 second
                const pace = parseFloat(checkpoint.mile) / elapsedTime;
                const checkpointData = {
                    name: checkpoint.name,
                    mile: checkpoint.mile,
                    completionTime: completionTime.toISOString(),
                    pace: pace
                };
                completed.push(checkpointData);
                localStorage.setItem('completedCheckpoints', JSON.stringify(completed));
                // Save the new pace
                localStorage.setItem('currentPace', pace.toString());
                setCurrentCardIndex(getCurrentCardIndex() + 1);
                renderCheckpoints();
            });

            return div;
        }

        function renderCheckpoints() {
            const checkpointsContainer = document.getElementById('checkpoints');
            
            // Cleanup any existing event listeners
            const existingCard = checkpointsContainer.firstElementChild;
            if (existingCard && existingCard.cleanup) {
                existingCard.cleanup();
            }
            
            checkpointsContainer.innerHTML = '';
            const completed = JSON.parse(localStorage.getItem('completedCheckpoints') || '[]');
            const currentPace = calculateCurrentPace();
            let currentCardIndex = getCurrentCardIndex();
            // Clamp to last card if out of bounds
            if (currentCardIndex >= checkpoints.length) currentCardIndex = checkpoints.length - 1;
            if (currentCardIndex < 0) currentCardIndex = 0;
            const checkpoint = checkpoints[currentCardIndex];
            let completedCheckpoint = completed.find(cp => cp.name === checkpoint.name);
            // Only render the current card
            const isNextActionable = true;
            const element = createCheckpointElement(checkpoint, currentPace, null, completedCheckpoint, isNextActionable);
            checkpointsContainer.appendChild(element);
            renderTimeline();
        }

        // Initialize race controls
        const startRaceButton = document.getElementById('startRace');
        const resetRaceButton = document.getElementById('resetRace');
        const resetModal = document.getElementById('resetConfirmModal');
        const confirmResetButton = document.getElementById('confirmReset');
        const cancelResetButton = document.getElementById('cancelReset');

        // Initialize checkpoints
        const checkpointsContainer = document.getElementById('checkpoints');
        const completed = JSON.parse(localStorage.getItem('completedCheckpoints') || '[]');
        const savedRaceStart = localStorage.getItem('raceStartTime');
        const savedRaceFinished = localStorage.getItem('raceFinished');
        const savedRaceFinishTime = localStorage.getItem('raceFinishTime');
        const savedPace = localStorage.getItem('currentPace');
        
        if (savedRaceStart) {
            raceStarted = true;
            raceStartTime = new Date(savedRaceStart);
            startRaceButton.disabled = true;
            resetRaceButton.disabled = false;
            if (savedRaceFinished && savedRaceFinishTime) {
                document.getElementById('raceTimer').textContent = savedRaceFinishTime;
            } else {
                // Start timer
                timerInterval = setInterval(updateTimer, 10);
                updateTimer();
            }
        } else {
            raceStarted = false;
            raceStartTime = null;
            startRaceButton.disabled = false;
            resetRaceButton.disabled = true;
            // Clear any existing timer
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
            document.getElementById('raceTimer').textContent = '00:00:00:00';
        }

        // Initialize current card index if not set
        if (!localStorage.getItem('currentCardIndex')) {
            localStorage.setItem('currentCardIndex', '0');
        }

        // Initial render
        renderCheckpoints();
        renderTimeline();

        // Add event listeners for race controls
        startRaceButton.addEventListener('click', () => {
            // Start the race
            raceStarted = true;
            raceStartTime = new Date();
            startRaceButton.disabled = true;
            resetRaceButton.disabled = false;
            
            // Enable all stop buttons
            document.querySelectorAll('.stop-button').forEach(button => {
                button.disabled = false;
            });

            // Start timer
            timerInterval = setInterval(updateTimer, 10);
            updateTimer();

            // Save race start to localStorage
            localStorage.setItem('raceStartTime', raceStartTime.toISOString());

            // Mark start checkpoint as completed
            const completed = JSON.parse(localStorage.getItem('completedCheckpoints') || '[]');
            const startCheckpoint = {
                name: checkpoints[0].name,
                mile: checkpoints[0].mile,
                completionTime: raceStartTime.toISOString(),
                pace: 0 // Initial pace is 0 since we're at the start
            };
            completed.push(startCheckpoint);
            localStorage.setItem('completedCheckpoints', JSON.stringify(completed));
            
            // Move to next card
            setCurrentCardIndex(getCurrentCardIndex() + 1);
            renderCheckpoints();
        });

        resetRaceButton.addEventListener('click', () => {
            resetModal.style.display = 'flex';
        });

        confirmResetButton.addEventListener('click', () => {
            raceStarted = false;
            raceStartTime = null;
            startRaceButton.disabled = false;
            resetRaceButton.disabled = true;
            // Stop timer
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
            document.getElementById('raceTimer').textContent = '00:00:00:00';
            // Disable all stop buttons
            document.querySelectorAll('.stop-button').forEach(button => {
                button.disabled = true;
            });
            
            // Clear only race-related data
            localStorage.removeItem('raceStartTime');
            localStorage.removeItem('raceFinished');
            localStorage.removeItem('raceFinishTime');
            localStorage.removeItem('completedCheckpoints');
            localStorage.removeItem('completedSleepCards');
            localStorage.removeItem('currentCardIndex');
            localStorage.removeItem('currentPace'); // Clear saved pace
            
            // Reset to initial state
            setCurrentCardIndex(0);
            // Hide modal
            resetModal.style.display = 'none';
            // Re-render everything
            renderCheckpoints();
            renderTimeline();
        });

        cancelResetButton.addEventListener('click', () => {
            resetModal.style.display = 'none';
        });

        // Close modal when clicking outside
        resetModal.addEventListener('click', (e) => {
            if (e.target === resetModal) {
                resetModal.style.display = 'none';
            }
        });

        // Add a function to sum all sleep durations and update estimated times
        function getTotalSleepMinutes() {
            const completed = JSON.parse(localStorage.getItem('completedCheckpoints') || '[]');
            return completed.reduce((sum, cp) => sum + (cp.sleepDuration ? cp.sleepDuration : 0), 0);
        }
        function updateEstimatedTimesWithSleep() {
            const completed = JSON.parse(localStorage.getItem('completedCheckpoints') || '[]');
            const lastCheckpoint = completed[completed.length - 1];
            if (!lastCheckpoint) return;
            const currentPace = calculateCurrentPace();
            const totalSleepMinutes = getTotalSleepMinutes();
            const remainingCheckpoints = checkpoints.filter(cp => 
                parseFloat(cp.mile) > parseFloat(lastCheckpoint.mile)
            );
            remainingCheckpoints.forEach(cp => {
                const estimatedTime = estimateNextTime(
                    parseFloat(lastCheckpoint.mile),
                    parseFloat(cp.mile),
                    new Date(lastCheckpoint.completionTime),
                    currentPace
                );
                // Add total sleep time to estimated arrival
                const arrivalWithSleep = new Date(estimatedTime.getTime() + totalSleepMinutes * 60000);
                const checkpointElement = document.querySelector(`[data-checkpoint="${cp.name}"]`);
                if (checkpointElement) {
                    // Update estimated time under checkpoint name
                    const headerTime = checkpointElement.querySelector('.checkpoint-time');
                    if (headerTime) {
                        const cpGoal = checkpointGoals[cp.name];
                        if (cpGoal) {
                            const hoursFromStart = cpGoal.mile / currentPace;
                            const raceStart = new Date('2025-06-13T09:00:00');
                            const arrival = new Date(raceStart.getTime() + hoursFromStart * 60 * 60 * 1000 + totalSleepMinutes * 60000);
                            let headerText = `${formatDate(arrival)} ${formatTime(arrival)} (${currentPace.toFixed(1)} mph)`;
                            const checkpointObj = checkpoints.find(c => c.name === cp.name);
                            if (checkpointObj && checkpointObj.time && checkpointObj.time.includes('Deadline')) {
                                const deadline = checkpointObj.time.match(/Deadline[^)]+/);
                                if (deadline) {
                                    headerText += ` — ${deadline[0]}`;
                                }
                            }
                            headerTime.textContent = headerText;
                        }
                    }
                    // Update badge
                    const goalTimesDiv = checkpointElement.querySelector('.goal-times');
                    if (goalTimesDiv) {
                        goalTimesDiv.innerHTML = getGoalTimes(cp.name, currentPace);
                    }
                }
            });
        }

        // --- Tinder-style single-card flow ---
        function getCurrentCardIndex() {
            return parseInt(localStorage.getItem('currentCardIndex') || '0', 10);
        }
        function setCurrentCardIndex(idx) {
            localStorage.setItem('currentCardIndex', idx);
        }
        function resetProgress() {
            localStorage.setItem('currentCardIndex', 0);
            localStorage.removeItem('completedCheckpoints');
            localStorage.removeItem('raceFinished');
            localStorage.removeItem('raceFinishTime');
        }

        function renderTimeline() {
            const timeline = document.getElementById('timeline');
            if (!timeline) return;
            const completed = JSON.parse(localStorage.getItem('completedCheckpoints') || '[]');
            const currentCardIndex = getCurrentCardIndex();
            const finished = localStorage.getItem('raceFinished');
            const finishTime = localStorage.getItem('raceFinishTime');
            let html = '<div class="timeline-outer">';
            html += '<ul class="timeline-list">';
            checkpoints.forEach((cp, idx) => {
                const completedCp = completed.find(c => c.name === cp.name);
                const isCurrent = checkpoints.findIndex(c => c.name === cp.name) === currentCardIndex;
                const isFinish = cp.isFinish;
                const isCompleted = completedCp || (isFinish && finished);
                const classes = ['timeline-item'];
                if (isCompleted) {
                    classes.push('checked-in');
                } else if (isCurrent) {
                    classes.push('current');
                }
                html += `<li class="${classes.join(' ')}" data-checkpoint-index="${checkpoints.findIndex(c => c.name === cp.name)}">`;
                html += `<span class="timeline-dot"></span>`;
                html += `<span class="timeline-label">${isFinish ? 'Seadrift - RACE FINISH' : cp.name}</span>`;
                html += `<span class="timeline-time">`;
                if (cp.name === 'Race Start') {
                    const startDate = new Date(RACE_START);
                    html += `${formatTime(startDate)}`;
                } else if (isFinish && finished && finishTime) {
                    const finishDate = new Date(RACE_START.getTime() + (parseInt(finishTime.split(':')[0]) * 60 * 60 * 1000) + 
                                             (parseInt(finishTime.split(':')[1]) * 60 * 1000) + 
                                             (parseInt(finishTime.split(':')[2]) * 1000));
                    html += `${formatTime(finishDate)}`;
                } else if (completedCp && completedCp.completionTime) {
                    const d = new Date(completedCp.completionTime);
                    html += `${formatTime(d)}`;
                } else {
                    html += '—';
                }
                html += `</span>`;
                html += `</li>`;
            });
            html += '</ul></div>';
            timeline.innerHTML = html;

            // Add click handlers for timeline items
            const timelineItems = timeline.querySelectorAll('.timeline-item');
            timelineItems.forEach(item => {
                item.addEventListener('click', () => {
                    const checkpointIndex = parseInt(item.getAttribute('data-checkpoint-index'));
                    const checkpoint = checkpoints[checkpointIndex];
                    const completed = JSON.parse(localStorage.getItem('completedCheckpoints') || '[]');
                    const completedCheckpoint = completed.find(cp => cp.name === checkpoint.name);
                    const currentPace = calculateCurrentPace();
                    
                    // Create checkpoint element for modal
                    const modalCheckpoint = document.getElementById('modalCheckpoint');
                    const element = createCheckpointElement(checkpoint, currentPace, null, completedCheckpoint, false);
                    modalCheckpoint.innerHTML = '';
                    modalCheckpoint.appendChild(element);

                    // Hide checkpoint-controls if all buttons are hidden
                    const controls = element.querySelector('.checkpoint-controls');
                    if (controls) {
                        const buttons = controls.querySelectorAll('.checkpoint-button');
                        const allHidden = Array.from(buttons).every(button => button.style.display === 'none');
                        if (allHidden) {
                            controls.style.display = 'none';
                        }
                    }
                    
                    // Show modal
                    const modal = document.getElementById('timelineModal');
                    modal.style.display = 'flex';
                });
            });
        }

        // Add click handler to close modal when clicking outside
        const timelineModal = document.getElementById('timelineModal');
        timelineModal.addEventListener('click', (e) => {
            if (e.target === timelineModal) {
                timelineModal.style.display = 'none';
            }
        });

        // Add styles for timeline items
        const style = document.createElement('style');
        style.textContent = `
            .timeline-item {
                cursor: pointer;
                transition: opacity 0.15s;
            }
            .timeline-item:hover {
                opacity: 0.8;
            }
            #timelineModal .modal-content {
                max-height: 90vh;
                overflow-y: auto;
            }
        `;
        document.head.appendChild(style);

        // Add share function
        function shareRaceResults() {
            const completed = JSON.parse(localStorage.getItem('completedCheckpoints') || '[]');
            const finishTime = localStorage.getItem('raceFinishTime');
            const raceStart = new Date(RACE_START);
            
            let emailBody = 'Texas Water Safari 2025 Race Results\n\n';
            emailBody += 'Checkpoint Times:\n';
            
            // Sort checkpoints by mile to ensure correct order
            completed.sort((a, b) => parseFloat(a.mile) - parseFloat(b.mile));
            
            completed.forEach(cp => {
                const d = new Date(cp.completionTime);
                // Ensure the date is valid and after race start
                if (d < raceStart) {
                    d.setTime(raceStart.getTime());
                }
                emailBody += `${cp.name} (Mile ${cp.mile}): ${formatDate(d)} ${formatTime(d)}\n`;
            });
            
            if (finishTime) {
                emailBody += `\nTotal Race Time: ${finishTime}\n`;
                
                // Calculate average pace
                const [hours, minutes, seconds] = finishTime.split(':').map(Number);
                const totalHours = hours + (minutes / 60) + (seconds / 3600);
                const averagePace = (260 / totalHours).toFixed(1);
                emailBody += `Average Pace: ${averagePace} mph\n`;
            }
            
            const subject = 'Texas Water Safari 2025 - Race Results';
            const mailtoLink = `mailto:?subject=${encodeURIComponent(subject)}&body=${encodeURIComponent(emailBody)}`;
            window.location.href = mailtoLink;
        }

        // Add storage quota management
        function checkStorageQuota() {
            try {
                if (navigator.storage && navigator.storage.estimate) {
                    navigator.storage.estimate().then(estimate => {
                        const usedPercentage = (estimate.usage / estimate.quota) * 100;
                        if (usedPercentage > 80) {
                            console.warn('Local storage is almost full:', usedPercentage.toFixed(2) + '% used');
                            // Optionally show a user warning
                        }
                    });
                }
            } catch (error) {
                console.error('Error checking storage quota:', error);
            }
        }

        // Check storage quota periodically
        setInterval(checkStorageQuota, 60000); // Check every minute

        // Add event listener for Reset Race & Clear Edits button
        document.getElementById('confirmResetWithEdits').addEventListener('click', () => {
            raceStarted = false;
            raceStartTime = null;
            startRaceButton.disabled = false;
            resetRaceButton.disabled = true;
            // Stop timer
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
            document.getElementById('raceTimer').textContent = '00:00:00:00';
            // Disable all stop buttons
            document.querySelectorAll('.stop-button').forEach(button => {
                button.disabled = true;
            });
            
            // Clear all data including edits
            localStorage.clear();
            
            // Reset to initial state
            setCurrentCardIndex(0);
            // Hide modal
            resetModal.style.display = 'none';
            // Re-render everything
            renderCheckpoints();
            renderTimeline();
        });
    </script>
    <div style="height: 60px;"></div>
</body>
</html>